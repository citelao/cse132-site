---
title: Programming and Bit Manipulation
author: Claire Heuckeroth and Ben Stolovitz
week: 1
assigned: 2016-01-25
due: 2016-01-25
---

* This is a TOC 
{:toc}

## Introduction

Now that you know how to use the command line, it's time to go a bit more in-depth about how it and your computer works, by compiling your first C program.

### C

If you took CSE131 or AP Computer Science, you should already be familiar with Java. We will still use a lot of Java in this class, but we're also switching the emphasis to another language called **C**. 

We do this for two reasons:

- You program Arduinos in C[^cpp]
- C is much closer to the hardware

[^cpp]: More accurately, you program them in a subset of C++, which adds classes to C.

Unlike Java, which runs on a virtual machine *on top* of your existing operating system, C compiles to pure machine language: the direct instruction set that your computer actually runs. In other words, if you'd like to see the exact instructions your computer uses to draw a pixel onscreen in a video game or download your email, you look at a compiled C program.

Lucky for us, *uncompiled* C (like, C code) looks a lot like Java. So much so that you should be able to read C with no problems and by the end of this studio be able to write and compile C programs with no fuss at all.

Compiled code is a different story. We'll deal with the human-readable "rendition"[^cite] of machine-language, Assembly, later in the semester, but for now we'll deal with the more immediate problem of how programs interact with the computer, a huge question in its own right[^ed] that we can best understand in a more sensible language.

[^cite]: Word taken from [wikipedia](https://en.wikipedia.org/wiki/Machine_code#Assembly_languages) for accuracy.

[^ed]: This was always something that confused me, and to this day I think the key to understanding programming is understanding the context in which programs are executed: how they get input, where they send output, etc. 

	For example, a web server is merely a computer (that other computers know the name of via DNS) running a program that waits for connections on some **port**, a stream of data generated by the operating system from a physical ethernet port or something similar, and then responds with appropriate data based on the input. Like, if I asked the Facebook servers for my profile, the program would send me the content of my profile.

## Studio proper

### Information representation

But before we can ever talk about I/O (input/output) and programs and compiling things, you need to understand how the computer stores data. In other words, before you can understand how computers manipulate data, you must know how they represent it.

To that end, we've prepared some pen-and-paper excercises to get you thinking about data like a computer does.

If you are having trouble with the concepts behind any of these questions, try reading Chapter 7 in the [course textbook](http://www.cse.wustl.edu/~roger/cse132/cc_v0_05.pdf) or look through the [Guide to Information Representation](TODO).

#### Binary & Bases

Binary is what every form of data on your computer eventually boils down to: some chain of `HIGH`s and `LOW`s, zeroes and ones. These questions will explore your understanding of binary as a base 2 number system.

The subscript on a number indicates its current base. If no base is given, assume base 10.

1. What is $1010_2$ in base 10?
2. What is $68_{10}$ in binary?
3. What is $20_{10}$ in base 6?

#### Hexadecimal

Hexadecimal is base 16. It ends up being a very nice way of representing computer-related numbers because it jives with binary so well.

1. What is $1010 0101_2$ in hexadecimal?
2. What is $0xF1$ in binary?
3. How many digits of binary correspond to a digit of hex?
4. Hex uses the letters `A` through `F` to go up to base 16. What is the highest base we can represent if we use all the letters of the alphabet?

## The mechanics of a program

You've built programs with Eclipse. You've written classes in Java before. But you probably haven't ever built a program the true "hacker" way, with a text editor, a compiler, and fifteen pages of reference open beside you. So let's build one.

1. SSH into the `shell.cec.wustl.edu` computers again (same steps as Studio 0).
2. Make sure you `qlogin`.
3. Browse to your repository working copy from Studio 0 and `svn update` to get some new files we've added to your repo.
4. Now `cd` to the directory c/studio1/ and then open helloworld.c in whichever text editor you last used, probably `nano`.

	There's not much code (in fact, it's not a complete program, but we'll get to that), but there's enough to show off some of the key differences between Java (which you're used to) and C.
	
	There are two major differences.
	
	The first is in the first line. This line declares a variable named `message`. The big difference from Java is its type, `char[]`. C does not have `String`s. Instead it uses arrays of `char`s (which makes sense: a string is conceptually a series of characters). We'll explore this further in a bit.
	
	<aside class="sidenote">
	<h3>Entry Points</h3>
	
	No matter what type of program you want to make, you need it to start somehow. We call the points in your code where you can begin a running program **entry points**. 
	
	You should be at least vaguely familiar with the way this works in Java: if a class has a method `public static void main(String[])` (the name of the `String[]` parameter doesn't matter), you can run it from within Eclipse. In Java, everything is a class, but when you start your program, you do not have instances of any classes (e.g. `Ball b = new Ball()` creates an instance of `Ball` named `b`). By creating a `public` method, you tell Java that other entities can call it---as opposed to `private`, which would indicate that only the class itself can call that method---but by declaring it `static`, you state that this method can be run independent of any instances. That is, in part, [what static means](http://stackoverflow.com/questions/413898/what-does-the-static-keyword-do-in-a-class) in Java.
	
	C has none of this. There are no classes in C, so no `public` or `static` nonsense. Programs return an `int`, not nothing---`0` if everything went well, something else if there was an error---and there are no `String`s. If you include a function called `int main(void)` or `int main(int argc, const char* argv[])` in your code, you have a valid **entry point**: your code can be compiled into a working program.
	
	And your program will start by calling `main()`.
	</aside>
	
	The other difference is the `int main()` function. This is the **entry point**, and it looks different from Java's. It functions the same though. You still call functions (`printf()` is similar to `System.out.println()`) and create variables within it.
5. But enough with analyzing the minutia of five-line programs. Let's compile it! 

	(There's secretly an error in the code, so this won't quite work)
	
	Use `gcc FILENAME` to compile your code.
6. This gives you a warning[^warnings]. What's the warning? Understanding exactly what it means requires another 3 years of computer science classes, but you can easily find a fix using Google.
	
	You should add exactly one line of code to the top of the `helloworld.c` file.
7. Recompile your fixed version. This produces a file called `a.out` in your current directory, which you can run by using shorthand for the current directory: `./a.out` (`.` indicates the current directory, `..` the parent).
8. This name is not descriptive, so recompile again, but with the `-o OUTPUTNAME` flag (`gcc INPUT -o OUTPUT`). I chose `helloworld`.
9. You've successfully compiled a program! Run it (`./WHATEVER_NAME_YOU_GAVE_IT`).

	Compiling frequently tends to make life easier, as you discover coding errors earlier on. I usually only write 5 or 6 lines before compiling. We can automate this process (and we will do this for the assignment), but for now, just know you can use the up and down arrow keys to browse through your command history in terminal.
	
[^warnings]: Yes, your program will still compile with warnings, but warnings are there for a reason. I generally compile with `-Werror`, which makes all warnings into errors, `-pedantic`, which makes many more things warn, and a slew of [other additional warnings](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html). If I see warnings in compiled code, I am immediately suspicious of it.

# The mechanics of C & bottles of beer

Now it's time to write your own program. It will automatically generate the [bottles of beer song](https://www.youtube.com/watch?v=3KnpZYkTWno) for as many bottles as you input.

<aside class="sidenote">
## Printf()
{:.no_toc}

`printf()` is a pretty daunting function. If you call it with just one parameter, a string: `printf(char[])`, it prints that string. However, this only works with string **literals**, hard-coded constants (like `"these are literally letters"`). It cannot be called like that for **symbolic** strings, like `char[] error = "This is an error"; printf(error);`

This is where the `printf()`'s true brawn comes in. It can **interpolate** placeholder values it calls **conversion specifications** or **format specifications** with variables passed as subsequent parameters.

For example, `printf("I had the %s.", "fish");` would print:

 `I had the fish`
 
 and `printf("%d of the %d passengers didn't have fish", 3, 90);` would print:

`3 of the 90 passengers didn't have fish`.

You can normally get a list of these format specifications by running `man printf`, except our version of the documentation doesn't. [This format cheatsheet](http://www.pixelbeat.org/programming/gcc/format_specs.html) should help the curious.
</aside>

1. Make a new file in the same `c/studio1` directory called `bottles.c`.
2. You will need to use the same `printf()` function that our `helloworld.c` program used, so write the same `#include` line as you did to fix the warning you got earlier.
3. Add an entry point to your code: a function called `int main(int argc, char** argv)`. This is *different*  than the `helloworld.c` `main()` because this new program is going to *take user input*.

	I suggest `printf()`ing some text and compiling to make sure everything is working. Remember: warnings are bad.
4. For now, hard-code the number of bottles on the wall as an `int` in your `main()`. It will look just like Java: `int bottles = 5;`.
5. Use a [`for` loop](http://www.tutorialspoint.com/cprogramming/c_for_loop.htm) (it's the same syntax as Java, but you'll be decrementing *from* `bottles` *to* `0`) & `printf()` to iterate through `bottles` to 0 and print the lyrics to the song. **Note**: To prevent any errors, do not declare any variables in the `for` loop declaration. Instead, declare it above the loop.
	
	 Remember that `1` bottle is a special case, and use `printf()`'s **format specification** `%d` to print the correct number (see sidebar **Printf()**).
6. Make sure your program works up until 99.

# Pandering to the user

You've written and compiled your first C program from scratch! Now, let's handle user input.

<aside class="sidenote">
## Asterisks and funny things
{:.no_toc}

Now you may be wondering how `char**` is an array of strings. Simple!

A `*` in a C type indicates that it is a **pointer**--- it *points* to the location in memory of an entry of that type. An `int` pointer would therefore be the memory location of a certain int.

We store arrays in C as memory locations of the first index in the array, so a `char[]` is the memory location of the first `char` in that array. When you index the array (`array[5]` or something similar), you **dereference** the pointer and pull the value at that memory location.

Thus you can consider a `char**` as a pointer to a `char` pointer, or, as mentioned earlier, a pointer to a `char[]`. Since a `char[]` is the C equivalent of a string, a `char**` can be thought of as an array of strings.

We will talk *much* more about pointers later, so don't worry if this is confusing.
</aside>

1. Notice that the entry point we used had two new parameters in lieu of `void` (which tells C our function accepts no arguments). We called them `int argc` and `char** argv`. These names are "canonical," the ones usually chosen. `argc` is an int indicating the *number of arguments*, or argument count, and `argv` is an array of strings---the argument values.

	If you simply execute your program the way you've been doing it (`./a.out` or similar), `argc` is `1`, and the first `argv` string is your program name: `a.out`, in this case.
	
	Make your program accept, at least rudimentarily, user input by looking at the first character in your second argument (`argv[1][0]`: arrays are zero-indexed). Use that as the number of bottles.
	
	**N.B.**: this won't be very robust. It can only take single-digit numbers and won't actually get the right number, as you'll see below.
2. This doesn't work too well! If you ask for 9 bottles of beer--- `./a.out 9`, you will get *57*[^fiftyseven]! 

	This is because the argument is not an `int`, it is an ASCII `char`. ASCII is an **encoding** that assigns letters to numbers. Up until now, we have only been able to represent numbers in binary, and that remains true, but if we *assign* letters to certain numbers, we can represent letters as well. Running the `man 7 ascii` command will show you a list of all ASCII characters. 
	
	What's the ASCII number for `0`? `A`? If this is confusing or difficult, consider reading Chapter 7 in the [course textbook](http://www.cse.wustl.edu/~roger/cse132/cc_v0_05.pdf) or looking through the [Guide to Information Representation](TODO).
	
	You'll notice that there are no non-English characters. ASCII is an American standard and can only represent pure Latin letters. Unicode is the standard encoding that can represent everything from Latin to Klingon to Arabic to [emoji](http://www.unicode.org/emoji/charts/emoji-candidates.html).
3. [Write a function](http://www.cs.utah.edu/~germain/PPS/Topics/C_Language/c_functions.html) separate from `main()` (above it in the file) that converts single ASCII characters `0` through `9` into the correct `int`.

	It should take a `char` as an argument and return an `int`. For reference, note that `int main(int argc, char** argv)` takes an `int` and a `char**` as arguments and returns an `int`.
	
	You should be able to do this by subtracting a constant from the argument.
4. Adjust your `main()` to use this function to convert single-digit numbers properly.

[^fiftyseven]: If you *don't* get 57 or 9, consult a TA. You are not reading correctly.

# Avoiding work

Now you can read single-digits properly. But how will you read longer numbers? It seems like you'd have to write some sort of weird `for` loop that goes through each digit---nonsense!

That function you wrote was for education<sup>tm</sup>. C already has a function that converts strings to integers, so use it to avoid a lot of work.

1. Include `stdlib.h` in your beer-singing program like you included `stdio.h`.
2. You can now use a [function called `atoi(char*)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/atoi.html) to convert strings into integers. 

	You want to send the second element in your `argv` array (`argv[1]`) through this function and use the number it returns as your number of bottles.
3. To test your program, recompile and execute `./a.out` or similar with the value `99`.

# Check out

This is not really a new part of this studio, but more of a reminder. If you're really pressed for time, skip to step 3 and **do not leave** before doing step 4.

1. Use `svn status` and `svn add` to add your new files to the repository where appropriate. You do *not* need to re-add tracked files (those that do not have `?`s).
2. Commit your new files using `svn commit -m "commit message"`
3. Find a TA to check out your studio so you get credit for your work.
4. **VERY IMPORTANT**: Type `logout` to end your `qlogin` session.
